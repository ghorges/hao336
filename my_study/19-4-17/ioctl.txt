在驱动程序中实现的ioctl函数体内，实际上是有一个switch{case}结构，每一个case对应一个命令码，做出一些相应的操作。怎么实现这些操作，这是每一个程序员自己的事情。因为设备都是特定的，这里也没法说。关键在于怎样组织命令码，因为在ioctl中命令码是唯一联系用户程序命令和驱动程序支持的途径。 命令码的组织是有一些讲究的，因为我们一定要做到命令和设备是一一对应的，这样才不会将正确的命令发给错误的设备，或者是把错误的命令发给正确的设备，或 者是把错误的命令发给错误的设备。这些错误都会导致不可预料的事情发生，而当程序员发现了这些奇怪的事情的时候，再来调试程序查找错误，那将是非常困难的 事情。所以在Linux核心中是这样定义一个命令码的： 
____________________________________
| 设备类型 | 序列号 | 方向 |数据尺寸|
|----------|--------|-------|-----------|
| 8 bit     | 8 bit  |2 bit |8~14 bit|
|----------|--------|-------|-----------|

    这样一来，一个命令就变成了一个整数形式的命令码；但是命令码非常的不直观，所以Linux Kernel中提供了一些宏。这些宏可根据便于理解的字符串生成命令码，或者是从命令码得到一些用户可以理解的字符串以标明这个命令对应的设备类型、设备序列号、数据传送方向和数据传输尺寸。

        这些宏我就不在这里解释了，具体的形式请读者察看Linux核心源代码中的宏，文件里给这些宏做了完整的定义。这里我只多说一个地方，那就是"幻数"。 "幻数"是一个字母，数据长度也是8，用一个特定的字母来标明设备类型，这和用一个数字是一样的，只是更加利于记忆和理解。就是这样，再没有更复杂的了。 更多的说了也没用，读者还是看一看源代码吧，推荐各位阅读《Linux 设备驱动程序》所带源代码中的short一例，因为它比较短小，功能比较简单，可以看明白ioctl的功能和细节。

        四、 cmd参数如何得出 
            这里确实要说一说，cmd参数在用户程序端由一些宏根据设备类型、序列号、传送方向、数据尺寸等生成，这个整数通过系统调用传递到内核中的驱动程序，再由驱动程序使用解码宏从这个整数中得到设备的类型、序列号、传送方向、数据尺寸等信息，然后通过switch{case}结构进行相应的操作。要透彻理解，只能是通过阅读源代码，我这篇文章实际上只是一个引子。cmd参数的组织还是比较复杂的，我认为要搞熟它还是得花不少时间的，但是这是值得的，因为驱动程序中最难的是对中断的理解。
